import rclpy  # ROS2 Python API
from rclpy.node import Node
from sensor_msgs.msg import Image  # ROS2 image message type
from cv_bridge import CvBridge  # Bridges ROS2 and OpenCV
import cv2  # Image processing library
import numpy as np  # For numerical operations (e.g., defining vertices)

# QoS for subscriber
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy

sensor_qos = QoSProfile(
    reliability=ReliabilityPolicy.BEST_EFFORT,
    history=HistoryPolicy.KEEP_LAST,
    depth=2
)


def region_of_interest(img):
    """ Apply mask to focus on the road area """
    height, width = img.shape
    mask = np.zeros_like(img)

    # Define trapezoidal ROI (adjust these values as needed)
    vertices = np.array([[
        [width * 0.1, height],          # Bottom left
        [width * 0.2, height * 0.6],    # Top left
        [width * 0.8, height * 0.6],    # Top right
        [width * 0.9, height]           # Bottom right
    ]], dtype=np.int32)

    cv2.fillPoly(mask, [vertices], 255)
    return cv2.bitwise_and(img, mask)


def detect_lines(edges):
    """ Detect lines using Hough Transform """
    return cv2.HoughLinesP(
        edges,
        rho=1,
        theta=np.pi / 180,
        threshold=20,
        minLineLength=20,
        maxLineGap=300
    )


def average_slope_intercept(lines):
    """ Average multiple detected lines into left/right lane lines """
    left_lines = []
    right_lines = []

    if lines is None:
        return None, None

    for line in lines:
        x1, y1, x2, y2 = line[0]

        # Skip vertical lines
        if x1 == x2:
            continue

        # Calculate slope and intercept
        slope = (y2 - y1) / (x2 - x1)
        intercept = y1 - slope * x1

        # Classify as left or right lane
        if slope < -0.5:  # Negative slope = left lane
            left_lines.append((slope, intercept))
        elif slope > 0.5:  # Positive slope = right lane
            right_lines.append((slope, intercept))

    # Average all left and right lines
    left_avg = np.average(left_lines, axis=0) if left_lines else None
    right_avg = np.average(right_lines, axis=0) if right_lines else None

    return left_avg, right_avg


def make_line_points(y1, y2, line):
    """ Convert slope/intercept to pixel coordinates """
    if line is None:
        return None

    slope, intercept = line
    x1 = int((y1 - intercept) / slope)
    x2 = int((y2 - intercept) / slope)
    y1, y2 = int(y1), int(y2)

    return ((x1, y1), (x2, y2))


def draw_lane_lines(frame, lines, color=(0, 255, 0), thickness=5):
    """ Draw the detected lane lines on the frame """
    left_avg, right_avg = average_slope_intercept(lines)
    y1 = frame.shape[0]  # Bottom of frame
    y2 = int(y1 * 0.6)   # Upper limit

    left_line = make_line_points(y1, y2, left_avg)
    right_line = make_line_points(y1, y2, right_avg)

    # Create blank image to draw lines on
    line_img = np.zeros_like(frame)

    # Draw the lines
    if left_line:
        cv2.line(line_img, *left_line, color, thickness)
    if right_line:
        cv2.line(line_img, *right_line, color, thickness)

    # Combine with original frame
    return cv2.addWeighted(frame, 0.8, line_img, 1.0, 0.0)


class ImageSubscriber(Node):
    def __init__(self):
        super().__init__('image_subscriber')

        self.subscription = self.create_subscription(
            Image,  # Waiting for Image messages
            '/image',  # Subscribe to /image topic
            self.listener_callback,  # Callback function
            10
        )
        self.img_canny_pub_ = self.create_publisher(Image, '/canny_edges', qos_profile=sensor_qos)
        self.bridge = CvBridge()

    def listener_callback(self, msg):
        """ Callback function to process received image """
        self.get_logger().info('Received an image!')

        try:
            # Convert ROS2 message to OpenCV format
            cv_image = self.bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')
            cv_image = cv2.resize(cv_image, (320, 240))
            # Process the image: Convert to grayscale and apply Gaussian Blur
            gray_img = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)
            blurred_img = cv2.GaussianBlur(gray_img, (5, 5), 1.4)

            # Apply Canny edge detection
            edges = cv2.Canny(blurred_img, 50, 150)

            # Mask the region of interest
            masked = region_of_interest(edges)

            # Detect lines using Hough Transform
            lines = detect_lines(masked)

            # Draw lane lines
            lane_img = draw_lane_lines(cv_image, lines)

            # Convert back to ROS2 Image message and publish
            msg_img = self.bridge.cv2_to_imgmsg(lane_img, encoding="bgr8")
            self.img_canny_pub_.publish(msg_img)

        except Exception as e:
            self.get_logger().error(f"Could not process image: {e}")


def main(args=None):
    rclpy.init(args=args)
    image_subscriber = ImageSubscriber()
    rclpy.spin(image_subscriber)
    image_subscriber.destroy_node()
    cv2.destroyAllWindows()
    rclpy.shutdown()


if __name__ == '__main__':
colcon build --packages-select ant_oxl --symlink-install    main()
